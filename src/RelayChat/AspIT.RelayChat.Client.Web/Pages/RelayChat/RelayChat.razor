@page "/relaychat"

@using AspIT.RelayChat.Entities
@using AspIT.RelayChat.Client.Web.Pages.ChatComponents
@using AspIT.RelayChat.SignalRLibrary
@using Microsoft.AspNetCore.SignalR.Client
@inject Chat chat;

@implements IDisposable
@inject UsernameState usernameState
@inject NavigationManager navigationManager

<!-- Used to make the UX better -->
@inject IJSRuntime jsRuntime

<PageTitle>RelayChat</PageTitle>
<head>
    <link href="css/RelayChat.css" rel="stylesheet" />
    <script src="js/RelayChat.js" defer></script>
</head>

<h3>RelayChat</h3>

<!-- This will display the connection status of the chat -->
<div class="connection-container">
    @if (chat.hubConnection?.State != HubConnectionState.Connected){
        <span>Connecting <p>❌</p></span>
    }
    else
    {
        <span>Connected <p>✔</p></span>
    }
</div>

<!--
<span></span>
<p>Username Container: <b>@usernameState.user.Username</b></p>
<p>Username chat: <b>@chat.usernameState.user.Username</b></p>
-->

<!-- This HAS to be here, otherwise the chat won't work -->
<UsernameInput OnSubmittedUsername="() => RunStateChanged()"></UsernameInput>

<div class="chat-container">
    <div class="message-container">
        <!-- The list of messages, I'll have to fix the styling and scrolling issues at some point -->
        <ul id="messagesList">
            @foreach (var message in messages)
            {
                <!-- TODO: remove the inline styling. And get the css files to work -->
                <li><b>@message.Sender.Username</b>: @message.Message</li>
            }
        </ul>
    </div>

    <div class="input-container">
        <!-- The input field and the button to send a message -->
        @if (chat.hubConnection?.State == HubConnectionState.Connected)
        {
            <input type="text" @bind="messageInput" @oninput="e => messageInput = e.Value.ToString()" @onkeydown="HandleKeyPress" placeholder="Your message..." />
            <button @onclick="SendMsg">Send</button>
        }
    </div>
</div>






@code {
    private HubConnection hubConnection; // The connection to the SignalR hub
    private List<ChatMessage> messages = new(); // The list of messages to display
    private string messageInput; // The text in the input field

    // public bool IsConnected => chat.hubConnection?.State == HubConnectionState.Connected; // A boolean to check if the chat is connected

    /// <summary>
    /// OnInitializedAsync is called when the component is initialized. It'll set the usernameState and the chat.usernameState to the same user.
    /// </summary>
    protected override async Task OnInitializedAsync()
    {
        if (usernameState.user == null)
        {
            // Set a default user or handle the null scenario
            Console.WriteLine("usernameState.User is null");
        }

        chat.usernameState = this.usernameState;
        chat.usernameState.UserChanged += StateHasChanged;

        chat.hubConnection.On<ChatMessage>("ReceiveNewMessage", msg =>
        {
            messages.Add(msg);

            InvokeAsync(StateHasChanged);
        });
    }

    // 
    private void ChangePropertyValue()
    {
        chat.usernameState.SetUsername("New value set in the State " +
            $"Container Example component: {DateTime.Now}");
    }

    // 
    public void Dispose()
    {
        chat.usernameState.UserChanged -= StateHasChanged;
    }

    // When the user clicks the button, the usernameState will be updated. TODO: Make it so the user can use the enter key to submit the message.
    private async Task SendMsg()
    {
        if (!string.IsNullOrEmpty(messageInput))
        {
            await chat.SendMessage(new ChatMessage { Message = messageInput, Sender = chat.usernameState.user });
            messageInput = string.Empty;
        }
    }

    // This method is called when the user submits their username. It'll update the usernameState and the chat.usernameState.
    private void RunStateChanged()
    {
        StateHasChanged();
        Console.WriteLine("State has changed");
    }

    private async Task HandleKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await SendMsg();
        }
    }

    // === === JavaScript Helpers === ===
    private async Task ScrollToBottom()
    {
        await jsRuntime.InvokeVoidAsync("scrollToBottom");
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (messages.Any())
        {
            await ScrollToBottom();
        }
    }

}
